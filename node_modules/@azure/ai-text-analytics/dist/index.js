'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
var url = require('url');
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');
var coreLro = require('@azure/core-lro');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "5.1.0-beta.3";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const MultiLanguageBatchInput = {
    type: {
        name: "Composite",
        className: "MultiLanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextDocumentInput"
                        }
                    }
                }
            }
        }
    }
};
const TextDocumentInput = {
    type: {
        name: "Composite",
        className: "TextDocumentInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobDescriptor = {
    type: {
        name: "Composite",
        className: "JobDescriptor",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobManifest = {
    type: {
        name: "Composite",
        className: "JobManifest",
        modelProperties: {
            tasks: {
                serializedName: "tasks",
                type: {
                    name: "Composite",
                    className: "JobManifestTasks"
                }
            }
        }
    }
};
const JobManifestTasks = {
    type: {
        name: "Composite",
        className: "JobManifestTasks",
        modelProperties: {
            entityRecognitionTasks: {
                serializedName: "entityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntitiesTask"
                        }
                    }
                }
            },
            entityRecognitionPiiTasks: {
                serializedName: "entityRecognitionPiiTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PiiTask"
                        }
                    }
                }
            },
            keyPhraseExtractionTasks: {
                serializedName: "keyPhraseExtractionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyPhrasesTask"
                        }
                    }
                }
            }
        }
    }
};
const EntitiesTask = {
    type: {
        name: "Composite",
        className: "EntitiesTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntitiesTaskParameters"
                }
            }
        }
    }
};
const EntitiesTaskParameters = {
    type: {
        name: "Composite",
        className: "EntitiesTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            stringIndexType: {
                defaultValue: "TextElements_v8",
                serializedName: "stringIndexType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "TextElements_v8",
                        "UnicodeCodePoint",
                        "Utf16CodeUnit"
                    ]
                }
            }
        }
    }
};
const PiiTask = {
    type: {
        name: "Composite",
        className: "PiiTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "PiiTaskParameters"
                }
            }
        }
    }
};
const PiiTaskParameters = {
    type: {
        name: "Composite",
        className: "PiiTaskParameters",
        modelProperties: {
            domain: {
                defaultValue: "none",
                serializedName: "domain",
                type: {
                    name: "String"
                }
            },
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            stringIndexType: {
                defaultValue: "TextElements_v8",
                serializedName: "stringIndexType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "TextElements_v8",
                        "UnicodeCodePoint",
                        "Utf16CodeUnit"
                    ]
                }
            }
        }
    }
};
const KeyPhrasesTask = {
    type: {
        name: "Composite",
        className: "KeyPhrasesTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "KeyPhrasesTaskParameters"
                }
            }
        }
    }
};
const KeyPhrasesTaskParameters = {
    type: {
        name: "Composite",
        className: "KeyPhrasesTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const TextAnalyticsError = {
    type: {
        name: "Composite",
        className: "TextAnalyticsError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InvalidRequest",
                        "InvalidArgument",
                        "InternalServerError",
                        "ServiceUnavailable",
                        "NotFound"
                    ]
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const TextDocumentBatchStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentBatchStatistics",
        modelProperties: {
            documentCount: {
                serializedName: "documentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            validDocumentCount: {
                serializedName: "validDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            erroneousDocumentCount: {
                serializedName: "erroneousDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const JobMetadata = {
    type: {
        name: "Composite",
        className: "JobMetadata",
        modelProperties: {
            createdDateTime: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            expirationDateTime: {
                serializedName: "expirationDateTime",
                type: {
                    name: "DateTime"
                }
            },
            jobId: {
                serializedName: "jobId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            lastUpdateDateTime: {
                serializedName: "lastUpdateDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "succeeded",
                        "failed",
                        "rejected",
                        "cancelled",
                        "cancelling",
                        "partiallyCompleted",
                        "partiallySucceeded"
                    ]
                }
            }
        }
    }
};
const TasksState = {
    type: {
        name: "Composite",
        className: "TasksState",
        modelProperties: {
            tasks: {
                serializedName: "tasks",
                type: {
                    name: "Composite",
                    className: "TasksStateTasks"
                }
            }
        }
    }
};
const TasksStateTasks = {
    type: {
        name: "Composite",
        className: "TasksStateTasks",
        modelProperties: {
            details: {
                serializedName: "details",
                type: {
                    name: "Composite",
                    className: "TaskState"
                }
            },
            completed: {
                serializedName: "completed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            failed: {
                serializedName: "failed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            inProgress: {
                serializedName: "inProgress",
                required: true,
                type: {
                    name: "Number"
                }
            },
            total: {
                serializedName: "total",
                required: true,
                type: {
                    name: "Number"
                }
            },
            entityRecognitionTasks: {
                serializedName: "entityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityRecognitionTasksItem"
                        }
                    }
                }
            },
            entityRecognitionPiiTasks: {
                serializedName: "entityRecognitionPiiTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityRecognitionPiiTasksItem"
                        }
                    }
                }
            },
            keyPhraseExtractionTasks: {
                serializedName: "keyPhraseExtractionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksKeyPhraseExtractionTasksItem"
                        }
                    }
                }
            }
        }
    }
};
const TaskState = {
    type: {
        name: "Composite",
        className: "TaskState",
        modelProperties: {
            lastUpdateDateTime: {
                serializedName: "lastUpdateDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "succeeded",
                        "failed",
                        "rejected",
                        "cancelled",
                        "cancelling",
                        "partiallyCompleted",
                        "partiallySucceeded"
                    ]
                }
            }
        }
    }
};
const Components15Gvwi3SchemasTasksstatePropertiesTasksPropertiesEntityrecognitiontasksItemsAllof1 = {
    type: {
        name: "Composite",
        className: "Components15Gvwi3SchemasTasksstatePropertiesTasksPropertiesEntityrecognitiontasksItemsAllof1",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntitiesResult"
                }
            }
        }
    }
};
const EntitiesResult = {
    type: {
        name: "Composite",
        className: "EntitiesResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentEntities = {
    type: {
        name: "Composite",
        className: "DocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const Entity = {
    type: {
        name: "Composite",
        className: "Entity",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subCategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TextAnalyticsWarning = {
    type: {
        name: "Composite",
        className: "TextAnalyticsWarning",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TextDocumentStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentStatistics",
        modelProperties: {
            characterCount: {
                serializedName: "charactersCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentError = {
    type: {
        name: "Composite",
        className: "DocumentError",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const Components15X8E9LSchemasTasksstatePropertiesTasksPropertiesEntityrecognitionpiitasksItemsAllof1 = {
    type: {
        name: "Composite",
        className: "Components15X8E9LSchemasTasksstatePropertiesTasksPropertiesEntityrecognitionpiitasksItemsAllof1",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "PiiResult"
                }
            }
        }
    }
};
const PiiResult = {
    type: {
        name: "Composite",
        className: "PiiResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PiiDocumentEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PiiDocumentEntities = {
    type: {
        name: "Composite",
        className: "PiiDocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            redactedText: {
                serializedName: "redactedText",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const Components1D9IzucSchemasTasksstatePropertiesTasksPropertiesKeyphraseextractiontasksItemsAllof1 = {
    type: {
        name: "Composite",
        className: "Components1D9IzucSchemasTasksstatePropertiesTasksPropertiesKeyphraseextractiontasksItemsAllof1",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "KeyPhraseResult"
                }
            }
        }
    }
};
const KeyPhraseResult = {
    type: {
        name: "Composite",
        className: "KeyPhraseResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentKeyPhrases"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentKeyPhrases = {
    type: {
        name: "Composite",
        className: "DocumentKeyPhrases",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyPhrases: {
                serializedName: "keyPhrases",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const Pagination = {
    type: {
        name: "Composite",
        className: "Pagination",
        modelProperties: {
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HealthcareResult = {
    type: {
        name: "Composite",
        className: "HealthcareResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentHealthcareEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentHealthcareEntities = {
    type: {
        name: "Composite",
        className: "DocumentHealthcareEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareEntity"
                        }
                    }
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareRelation"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const HealthcareEntityLink = {
    type: {
        name: "Composite",
        className: "HealthcareEntityLink",
        modelProperties: {
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HealthcareRelation = {
    type: {
        name: "Composite",
        className: "HealthcareRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            bidirectional: {
                serializedName: "bidirectional",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EntityLinkingResult = {
    type: {
        name: "Composite",
        className: "EntityLinkingResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLinkedEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLinkedEntities = {
    type: {
        name: "Composite",
        className: "DocumentLinkedEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LinkedEntity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const LinkedEntity = {
    type: {
        name: "Composite",
        className: "LinkedEntity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            matches: {
                serializedName: "matches",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Match"
                        }
                    }
                }
            },
            language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceEntityId: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            bingEntitySearchApiId: {
                serializedName: "bingId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Match = {
    type: {
        name: "Composite",
        className: "Match",
        modelProperties: {
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LanguageBatchInput = {
    type: {
        name: "Composite",
        className: "LanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectLanguageInput"
                        }
                    }
                }
            }
        }
    }
};
const DetectLanguageInput = {
    type: {
        name: "Composite",
        className: "DetectLanguageInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            countryHint: {
                serializedName: "countryHint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageResult = {
    type: {
        name: "Composite",
        className: "LanguageResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLanguage"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLanguage = {
    type: {
        name: "Composite",
        className: "DocumentLanguage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            detectedLanguage: {
                serializedName: "detectedLanguage",
                type: {
                    name: "Composite",
                    className: "DetectedLanguage"
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const DetectedLanguage = {
    type: {
        name: "Composite",
        className: "DetectedLanguage",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            iso6391Name: {
                serializedName: "iso6391Name",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentimentResponse = {
    type: {
        name: "Composite",
        className: "SentimentResponse",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSentiment"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentSentiment = {
    type: {
        name: "Composite",
        className: "DocumentSentiment",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative", "mixed"]
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            sentenceSentiments: {
                serializedName: "sentences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceSentiment"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            }
        }
    }
};
const SentimentConfidenceScores = {
    type: {
        name: "Composite",
        className: "SentimentConfidenceScores",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            neutral: {
                serializedName: "neutral",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentenceSentiment = {
    type: {
        name: "Composite",
        className: "SentenceSentiment",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            aspects: {
                serializedName: "aspects",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceAspect"
                        }
                    }
                }
            },
            opinions: {
                serializedName: "opinions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceOpinion"
                        }
                    }
                }
            }
        }
    }
};
const SentenceAspect = {
    type: {
        name: "Composite",
        className: "SentenceAspect",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "AspectConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AspectRelation"
                        }
                    }
                }
            }
        }
    }
};
const AspectConfidenceScoreLabel = {
    type: {
        name: "Composite",
        className: "AspectConfidenceScoreLabel",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AspectRelation = {
    type: {
        name: "Composite",
        className: "AspectRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["opinion", "aspect"]
                }
            },
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentenceOpinion = {
    type: {
        name: "Composite",
        className: "SentenceOpinion",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "AspectConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            isNegated: {
                serializedName: "isNegated",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AnalyzeBatchInput = {
    type: {
        name: "Composite",
        className: "AnalyzeBatchInput",
        modelProperties: Object.assign(Object.assign(Object.assign({}, JobDescriptor.type.modelProperties), JobManifest.type.modelProperties), { analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageBatchInput"
                }
            } })
    }
};
const AnalyzeJobState = {
    type: {
        name: "Composite",
        className: "AnalyzeJobState",
        modelProperties: Object.assign(Object.assign(Object.assign(Object.assign({}, JobMetadata.type.modelProperties), TasksState.type.modelProperties), Pagination.type.modelProperties), { errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            }, statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            } })
    }
};
const HealthcareJobState = {
    type: {
        name: "Composite",
        className: "HealthcareJobState",
        modelProperties: Object.assign(Object.assign(Object.assign({}, JobMetadata.type.modelProperties), Pagination.type.modelProperties), { results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "HealthcareResult"
                }
            }, errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            } })
    }
};
const TasksStateTasksEntityRecognitionTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityRecognitionTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), Components15Gvwi3SchemasTasksstatePropertiesTasksPropertiesEntityrecognitiontasksItemsAllof1
            .type.modelProperties)
    }
};
const TasksStateTasksEntityRecognitionPiiTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityRecognitionPiiTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), Components15X8E9LSchemasTasksstatePropertiesTasksPropertiesEntityrecognitionpiitasksItemsAllof1
            .type.modelProperties)
    }
};
const TasksStateTasksKeyPhraseExtractionTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksKeyPhraseExtractionTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), Components1D9IzucSchemasTasksstatePropertiesTasksPropertiesKeyphraseextractiontasksItemsAllof1
            .type.modelProperties)
    }
};
const TasksStateTasksDetails = {
    type: {
        name: "Composite",
        className: "TasksStateTasksDetails",
        modelProperties: Object.assign({}, TaskState.type.modelProperties)
    }
};
const HealthcareEntity = {
    type: {
        name: "Composite",
        className: "HealthcareEntity",
        modelProperties: Object.assign(Object.assign({}, Entity.type.modelProperties), { isNegated: {
                serializedName: "isNegated",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, links: {
                serializedName: "links",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareEntityLink"
                        }
                    }
                }
            } })
    }
};
const GeneratedClientAnalyzeHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientCancelHealthJobHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientCancelHealthJobHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientHealthHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientHealthHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MultiLanguageBatchInput: MultiLanguageBatchInput,
    TextDocumentInput: TextDocumentInput,
    JobDescriptor: JobDescriptor,
    JobManifest: JobManifest,
    JobManifestTasks: JobManifestTasks,
    EntitiesTask: EntitiesTask,
    EntitiesTaskParameters: EntitiesTaskParameters,
    PiiTask: PiiTask,
    PiiTaskParameters: PiiTaskParameters,
    KeyPhrasesTask: KeyPhrasesTask,
    KeyPhrasesTaskParameters: KeyPhrasesTaskParameters,
    ErrorResponse: ErrorResponse,
    TextAnalyticsError: TextAnalyticsError,
    InnerError: InnerError,
    TextDocumentBatchStatistics: TextDocumentBatchStatistics,
    JobMetadata: JobMetadata,
    TasksState: TasksState,
    TasksStateTasks: TasksStateTasks,
    TaskState: TaskState,
    Components15Gvwi3SchemasTasksstatePropertiesTasksPropertiesEntityrecognitiontasksItemsAllof1: Components15Gvwi3SchemasTasksstatePropertiesTasksPropertiesEntityrecognitiontasksItemsAllof1,
    EntitiesResult: EntitiesResult,
    DocumentEntities: DocumentEntities,
    Entity: Entity,
    TextAnalyticsWarning: TextAnalyticsWarning,
    TextDocumentStatistics: TextDocumentStatistics,
    DocumentError: DocumentError,
    Components15X8E9LSchemasTasksstatePropertiesTasksPropertiesEntityrecognitionpiitasksItemsAllof1: Components15X8E9LSchemasTasksstatePropertiesTasksPropertiesEntityrecognitionpiitasksItemsAllof1,
    PiiResult: PiiResult,
    PiiDocumentEntities: PiiDocumentEntities,
    Components1D9IzucSchemasTasksstatePropertiesTasksPropertiesKeyphraseextractiontasksItemsAllof1: Components1D9IzucSchemasTasksstatePropertiesTasksPropertiesKeyphraseextractiontasksItemsAllof1,
    KeyPhraseResult: KeyPhraseResult,
    DocumentKeyPhrases: DocumentKeyPhrases,
    Pagination: Pagination,
    HealthcareResult: HealthcareResult,
    DocumentHealthcareEntities: DocumentHealthcareEntities,
    HealthcareEntityLink: HealthcareEntityLink,
    HealthcareRelation: HealthcareRelation,
    EntityLinkingResult: EntityLinkingResult,
    DocumentLinkedEntities: DocumentLinkedEntities,
    LinkedEntity: LinkedEntity,
    Match: Match,
    LanguageBatchInput: LanguageBatchInput,
    DetectLanguageInput: DetectLanguageInput,
    LanguageResult: LanguageResult,
    DocumentLanguage: DocumentLanguage,
    DetectedLanguage: DetectedLanguage,
    SentimentResponse: SentimentResponse,
    DocumentSentiment: DocumentSentiment,
    SentimentConfidenceScores: SentimentConfidenceScores,
    SentenceSentiment: SentenceSentiment,
    SentenceAspect: SentenceAspect,
    AspectConfidenceScoreLabel: AspectConfidenceScoreLabel,
    AspectRelation: AspectRelation,
    SentenceOpinion: SentenceOpinion,
    AnalyzeBatchInput: AnalyzeBatchInput,
    AnalyzeJobState: AnalyzeJobState,
    HealthcareJobState: HealthcareJobState,
    TasksStateTasksEntityRecognitionTasksItem: TasksStateTasksEntityRecognitionTasksItem,
    TasksStateTasksEntityRecognitionPiiTasksItem: TasksStateTasksEntityRecognitionPiiTasksItem,
    TasksStateTasksKeyPhraseExtractionTasksItem: TasksStateTasksKeyPhraseExtractionTasksItem,
    TasksStateTasksDetails: TasksStateTasksDetails,
    HealthcareEntity: HealthcareEntity,
    GeneratedClientAnalyzeHeaders: GeneratedClientAnalyzeHeaders,
    GeneratedClientCancelHealthJobHeaders: GeneratedClientCancelHealthJobHeaders,
    GeneratedClientHealthHeaders: GeneratedClientHealthHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: ["options", "body"],
    mapper: AnalyzeBatchInput
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const jobId = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const includeStatistics = {
    parameterPath: ["options", "includeStatistics"],
    mapper: {
        serializedName: "showStats",
        type: {
            name: "Boolean"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        defaultValue: 20,
        constraints: {
            InclusiveMaximum: 50,
            InclusiveMinimum: 1
        },
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const jobId1 = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const input = {
    parameterPath: "input",
    mapper: MultiLanguageBatchInput
};
const modelVersion = {
    parameterPath: ["options", "modelVersion"],
    mapper: {
        serializedName: "model-version",
        type: {
            name: "String"
        }
    }
};
const stringIndexType = {
    parameterPath: ["options", "stringIndexType"],
    mapper: {
        defaultValue: "TextElements_v8",
        serializedName: "stringIndexType",
        type: {
            name: "String"
        }
    }
};
const domain = {
    parameterPath: ["options", "domain"],
    mapper: {
        serializedName: "domain",
        type: {
            name: "String"
        }
    }
};
const input1 = {
    parameterPath: "input",
    mapper: LanguageBatchInput
};
const opinionMining = {
    parameterPath: ["options", "opinionMining"],
    mapper: {
        serializedName: "opinionMining",
        type: {
            name: "Boolean"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "@azure/ai-text-analytics";
const packageVersion = "5.1.0-beta.3";
class GeneratedClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri =
            options.endpoint || "{Endpoint}/text/analytics/v3.1-preview.3";
        // Parameter assignments
        this.endpoint = endpoint;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed.
     * @param options The options parameters.
     */
    analyze(options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ options: operationOptions }, analyzeOperationSpec);
    }
    /**
     * Get the status of an analysis job.  A job may consist of one or more tasks.  Once all tasks are
     * completed, the job will transition to the completed state and results will be available for each
     * task.
     * @param jobId Job ID for Analyze
     * @param options The options parameters.
     */
    analyzeStatus(jobId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ jobId, options: operationOptions }, analyzeStatusOperationSpec);
    }
    /**
     * Get details of the healthcare prediction job specified by the jobId.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    healthStatus(jobId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ jobId, options: operationOptions }, healthStatusOperationSpec);
    }
    /**
     * Cancel healthcare prediction job.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    cancelHealthJob(jobId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ jobId, options: operationOptions }, cancelHealthJobOperationSpec);
    }
    /**
     * Start a healthcare analysis job to recognize healthcare related entities (drugs, conditions,
     * symptoms, etc) and their relations.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    health(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, healthOperationSpec);
    }
    /**
     * The API returns a list of general named entities in a given document. For the list of supported
     * entity types, check <a href="https://aka.ms/taner">Supported Entity Types in Text Analytics API</a>.
     * See the <a href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list
     * of enabled languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionGeneral(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, entitiesRecognitionGeneralOperationSpec);
    }
    /**
     * The API returns a list of entities with personal information (\"SSN\", \"Bank Account\" etc) in the
     * document. For the list of supported entity types, check <a href="https://aka.ms/tanerpii">Supported
     * Entity Types in Text Analytics API</a>. See the <a href="https://aka.ms/talangs">Supported languages
     * in Text Analytics API</a> for the list of enabled languages.
     *
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionPii(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, entitiesRecognitionPiiOperationSpec);
    }
    /**
     * The API returns a list of recognized entities with links to a well-known knowledge base. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesLinking(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, entitiesLinkingOperationSpec);
    }
    /**
     * The API returns a list of strings denoting the key phrases in the input text. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    keyPhrases(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, keyPhrasesOperationSpec);
    }
    /**
     * The API returns the detected language and a numeric score between 0 and 1. Scores close to 1
     * indicate 100% certainty that the identified language is true. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze for language endpoint.
     * @param options The options parameters.
     */
    languages(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, languagesOperationSpec);
    }
    /**
     * The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple
     * levels of granularity, start from the a document level, down to sentence and key terms (aspects) and
     * opinions.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    sentiment(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, sentimentOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const analyzeOperationSpec = {
    path: "/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeHeaders
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: body,
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const analyzeStatusOperationSpec = {
    path: "/analyze/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeJobState
        },
        404: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        includeStatistics,
        top,
        skip
    ],
    urlParameters: [endpoint, jobId],
    headerParameters: [accept1],
    serializer
};
const healthStatusOperationSpec = {
    path: "/entities/health/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HealthcareJobState
        },
        404: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        includeStatistics,
        top,
        skip
    ],
    urlParameters: [endpoint, jobId1],
    headerParameters: [accept1],
    serializer
};
const cancelHealthJobOperationSpec = {
    path: "/entities/health/jobs/{jobId}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: GeneratedClientCancelHealthJobHeaders
        },
        404: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    urlParameters: [endpoint, jobId1],
    headerParameters: [accept1],
    serializer
};
const healthOperationSpec = {
    path: "/entities/health/jobs",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientHealthHeaders
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: input,
    queryParameters: [modelVersion, stringIndexType],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesRecognitionGeneralOperationSpec = {
    path: "/entities/recognition/general",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntitiesResult
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesRecognitionPiiOperationSpec = {
    path: "/entities/recognition/pii",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PiiResult
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        domain
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesLinkingOperationSpec = {
    path: "/entities/linking",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntityLinkingResult
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const keyPhrasesOperationSpec = {
    path: "/keyPhrases",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: KeyPhraseResult
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: input,
    queryParameters: [includeStatistics, modelVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const languagesOperationSpec = {
    path: "/languages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LanguageResult
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: input1,
    queryParameters: [includeStatistics, modelVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const sentimentOperationSpec = {
    path: "/sentiment",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SentimentResponse
        },
        400: {
            bodyMapper: ErrorResponse,
            isError: true
        },
        500: {
            bodyMapper: ErrorResponse,
            isError: true
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        opinionMining
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("ai-text-analytics");

// Copyright (c) Microsoft Corporation.
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * @ignore
 * @param sortedArray An array of entries sorted by `id`
 * @param unsortedArray An array of entries that contain `id` but are not sorted
 */
function sortResponseIdObjects(sortedArray, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedArray.length) {
        const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    const result = [];
    for (const sortedItem of sortedArray) {
        const item = unsortedMap.get(sortedItem.id);
        if (item) {
            result.push(item);
        }
    }
    return result;
}
function findOpinionIndex(pointer) {
    const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/opinions\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        const opinionIndex = {
            document: parseInt(res[1]),
            sentence: parseInt(res[2]),
            opinion: parseInt(res[3])
        };
        return opinionIndex;
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid opinion pointer`);
    }
}
const jsEncodingUnit = "Utf16CodeUnit";
function addStrEncodingParam(options) {
    return Object.assign(Object.assign({}, options), { stringIndexType: jsEncodingUnit });
}
function addEncodingParamToTask(task) {
    task.stringIndexType = jsEncodingUnit;
    return task;
}
function AddParamsToTask(task) {
    return { parameters: task };
}
function nextLinkToTopAndSkip(nextLink) {
    const url$1 = new url.URL(nextLink);
    const searchParams = new url.URLSearchParams(url$1.searchParams);
    let top;
    if (searchParams.has("$top")) {
        top = parseInt(searchParams.get("$top"));
    }
    else {
        throw new Error(`nextLink URL does not have the $top param: ${nextLink}`);
    }
    let skip;
    if (searchParams.has("$skip")) {
        skip = parseInt(searchParams.get("$skip"));
    }
    else {
        throw new Error(`nextLink URL does not have the $skip param: ${nextLink}`);
    }
    return {
        skip: skip,
        top: top
    };
}
function getJobID(operationLocation) {
    const lastSlashIndex = operationLocation.lastIndexOf("/");
    return operationLocation.substring(lastSlashIndex + 1);
}
/**
 * parses incoming errors from the service and if the inner error code is
 * InvalidDocumentBatch, it exposes that as the statusCode instead.
 * @param error the incoming error
 */
function handleInvalidDocumentBatch(error) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const innerCode = (_d = (_c = (_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.innererror) === null || _d === void 0 ? void 0 : _d.code;
    const innerMessage = (_h = (_g = (_f = (_e = error.response) === null || _e === void 0 ? void 0 : _e.parsedBody) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.innererror) === null || _h === void 0 ? void 0 : _h.message;
    return innerCode === "InvalidDocumentBatch"
        ? new coreHttp.RestError(innerMessage, innerCode, error.statusCode)
        : error;
}

// Copyright (c) Microsoft Corporation.
/**
 * Helper function for converting nested service error into
 * the unified TextAnalyticsError
 */
function intoTextAnalyticsError(errorModel) {
    // Return the deepest error. This will always be at most
    // one level for TextAnalytics
    if (errorModel.innererror !== undefined) {
        return intoTextAnalyticsError(errorModel.innererror);
    }
    return {
        code: errorModel.code,
        message: errorModel.message,
        target: errorModel.target
    };
}
function makeTextAnalyticsSuccessResult(id, warnings, statistics) {
    return {
        id,
        statistics,
        warnings
    };
}
function makeTextAnalyticsErrorResult(id, error) {
    return {
        id,
        error: intoTextAnalyticsError(error)
    };
}
/**
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array.
 * @param input the array of documents sent to the service for processing.
 * @param response the response received from the service.
 */
function combineSuccessfulAndErroneousDocuments(input, response) {
    return processAndCombineSuccessfulAndErroneousDocuments(input, response, (x) => x);
}
/**
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array.
 * @param input the array of documents sent to the service for processing.
 * @param response the response received from the service.
 * @param process a function to convert the results from one type to another.
 */
function processAndCombineSuccessfulAndErroneousDocuments(input, response, process) {
    const unsortedResult = response.documents
        .map((document) => process(document))
        .concat(response.errors.map((error) => {
        return makeTextAnalyticsErrorResult(error.id, error.error);
    }));
    return sortResponseIdObjects(input, unsortedResult);
}

// Copyright (c) Microsoft Corporation.
function makeDetectLanguageResult(id, detectedLanguage, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { primaryLanguage: detectedLanguage });
}
function makeDetectLanguageErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeDetectLanguageResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeDetectLanguageResult(document.id, document.detectedLanguage, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeDetectLanguageErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeCategorizedEntitiesResult(id, entities, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeCategorizedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeCategorizedEntitiesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizeCategorizedEntitiesResult(document.id, document.entities, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeRecognizeCategorizedEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeAnalyzeSentimentResult(document) {
    const { id, sentiment, confidenceScores, sentenceSentiments: sentences, warnings, statistics } = document;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { sentiment,
        confidenceScores, sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, document)) });
}
function makeAnalyzeSentimentErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}
/**
 * Converts a sentence sentiment object returned by the service to another that
 * is user-friendly.
 *
 * @param sentence - The sentence sentiment object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly sentence sentiment object.
 */
function convertGeneratedSentenceSentiment(sentence, document) {
    return {
        confidenceScores: sentence.confidenceScores,
        sentiment: sentence.sentiment,
        text: sentence.text,
        offset: sentence.offset,
        minedOpinions: sentence.aspects
            ? sentence.aspects.map((aspect) => ({
                aspect: {
                    confidenceScores: aspect.confidenceScores,
                    sentiment: aspect.sentiment,
                    text: aspect.text,
                    offset: aspect.offset
                },
                opinions: aspect.relations
                    .filter((relation) => relation.relationType === "opinion")
                    .map((relation) => convertAspectRelationToOpinionSentiment(relation, document))
            }))
            : []
    };
}
/**
 * Converts an aspect relation object returned by the service to an opinion
 * sentiment object where JSON pointers in the former are realized in the
 * latter.
 *
 * @param aspectRelation - The aspect relation object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly opinion sentiment object.
 */
function convertAspectRelationToOpinionSentiment(aspectRelation, document) {
    var _a, _b;
    const opinionPtr = aspectRelation.ref;
    const opinionIndex = findOpinionIndex(opinionPtr);
    const opinion = (_b = (_a = document.sentenceSentiments) === null || _a === void 0 ? void 0 : _a[opinionIndex.sentence].opinions) === null || _b === void 0 ? void 0 : _b[opinionIndex.opinion];
    if (opinion !== undefined) {
        return opinion;
    }
    else {
        throw new Error(`Pointer "${opinionPtr}" is not a valid opinion pointer`);
    }
}

// Copyright (c) Microsoft Corporation.
function makeAnalyzeSentimentResultArray(input, response) {
    const { documents, errors, modelVersion, statistics } = response;
    const unsortedResult = documents
        .map((document) => {
        return makeAnalyzeSentimentResult(document);
    })
        .concat(errors.map((error) => {
        return makeAnalyzeSentimentErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeExtractKeyPhrasesResult(id, keyPhrases, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { keyPhrases });
}
function makeExtractKeyPhrasesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeExtractKeyPhrasesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeExtractKeyPhrasesResult(document.id, document.keyPhrases, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeExtractKeyPhrasesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizePiiEntitiesResult(document) {
    const { id, entities, warnings, statistics, redactedText } = document;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities,
        redactedText });
}
function makeRecognizePiiEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizePiiEntitiesResultArray(input, response) {
    const { documents, errors, statistics, modelVersion } = response;
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizePiiEntitiesResult(document);
    })
        .concat(errors.map((error) => {
        return makeRecognizePiiEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeLinkedEntitiesResult(id, entities, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeLinkedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeLinkedEntitiesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizeLinkedEntitiesResult(document.id, document.entities, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeRecognizeLinkedEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @ignore
 * @param name The name of the operation being performed.
 * @param tracingOptions The options for the underlying http request.
 */
function createSpan(operationName, operationOptions) {
    const tracer = coreTracing.getTracer();
    const tracingOptions = operationOptions.tracingOptions || {};
    const spanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { kind: api.SpanKind.INTERNAL });
    const span = tracer.startSpan(`Azure.CognitiveServices.TextAnalytics.${operationName}`, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.CognitiveServices");
    let newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording()) {
        newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.CognitiveServices" }) });
    }
    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions });
    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
        span,
        updatedOptions: newOperationOptions
    };
}

// Copyright (c) Microsoft Corporation.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 */
function createTextAnalyticsAzureKeyCredentialPolicy(credential) {
    return {
        create: (nextPolicy, options) => {
            return new TextAnalyticsAzureKeyCredentialPolicy(nextPolicy, options, credential);
        }
    };
}
/**
 * A concrete implementation of an AzureKeyCredential policy
 * using the appropriate header for TextAnalytics
 */
class TextAnalyticsAzureKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, credential) {
        super(nextPolicy, options);
        this.credential = credential;
    }
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Common properties and methods of analysis Pollers.
 */
class AnalysisPoller extends coreLro.Poller {
    constructor() {
        super(...arguments);
        /**
         * Defines how much time the poller is going to wait before making a new request to the service.
         */
        this.updateIntervalInMs = 2000;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     */
    delay() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return coreHttp.delay(this.updateIntervalInMs);
        });
    }
}
/**
 * Common properties and methods of polling operations.
 */
class AnalysisPollOperation {
    constructor(state) {
        this.state = state;
    }
    /**
     * @summary Serializes the Poller operation.
     */
    toString() {
        return JSON.stringify({
            state: this.state
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits for the healthcare results.
 */
class BeginAnalyzeHealthcarePollerOperation extends AnalysisPollOperation {
    constructor(state, 
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, documents, options = {}, statusOptions) {
        super(state);
        this.state = state;
        this.client = client;
        this.documents = documents;
        this.options = options;
        this.statusOptions = statusOptions;
    }
    /**
     * should be called only after all the status of the healthcare jobs became
     * "succeeded" and it returns an iterator for the results and provides a
     * byPage method to return the results paginated.
     */
    listHealthcareEntitiesByPage(jobId, options = {}) {
        const iter = this._listHealthcareEntities(jobId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
                return this._listHealthcareEntitiesPaginated(jobId, pageOptions);
            }
        };
    }
    /**
     * returns an iterator to the results of a healthcare job.
     */
    _listHealthcareEntities(jobId, options) {
        return tslib.__asyncGenerator(this, arguments, function* _listHealthcareEntities_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this._listHealthcareEntitiesPaginated(jobId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * returns an iterator to arrays of the results of a healthcare job.
     */
    _listHealthcareEntitiesPaginated(jobId, options) {
        return tslib.__asyncGenerator(this, arguments, function* _listHealthcareEntitiesPaginated_1() {
            let response = yield tslib.__await(this._listHealthcareEntitiesSinglePage(jobId, options));
            yield yield tslib.__await(response.result);
            while (response.skip) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
                response = yield tslib.__await(this._listHealthcareEntitiesSinglePage(jobId, optionsWithContinuation));
                yield yield tslib.__await(response.result);
            }
        });
    }
    /**
     * returns an iterator to arrays of the sorted results of a healthcare job.
     */
    _listHealthcareEntitiesSinglePage(jobId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listHealthcareEntitiesSinglePage", options || {});
            try {
                const response = yield this.client.healthStatus(jobId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                if (response.results) {
                    const result = combineSuccessfulAndErroneousDocuments(this.documents, response.results);
                    return response.nextLink
                        ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
                }
                else {
                    throw new Error("Healthcare task has succeeded but the there are no results!");
                }
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * returns whether the healthcare job is done and if so returns also
     * statistics and the model version used.
     */
    getHealthStatus(jobId, options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getHealthStatus", options || {});
            try {
                const response = yield this.client.healthStatus(jobId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                switch (response.status) {
                    case "succeeded": {
                        if (response.results) {
                            return {
                                done: true,
                                statistics: response.results.statistics,
                                modelVersion: response.results.modelVersion
                            };
                        }
                        else {
                            throw new Error("Healthcare task has succeeded but the there are no results!");
                        }
                    }
                    case "failed": {
                        const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const message = `Healthcare analysis failed. Error(s): ${errors || ""}`;
                        throw new Error(message);
                    }
                    case "notStarted":
                    case "running":
                        break;
                    default: {
                        throw new Error("Unrecognized state of healthcare job!");
                    }
                }
                return { done: false };
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    beginAnalyzeHealthcare(documents, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyzeHealthcare", addStrEncodingParam(options));
            try {
                return yield this.client.health({ documents: documents }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
            }
            catch (e) {
                const exception = handleInvalidDocumentBatch(e);
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: exception.message
                });
                throw exception;
            }
            finally {
                span.end();
            }
        });
    }
    update(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            const updatedAbortSignal = options.abortSignal;
            if (!state.isStarted) {
                state.isStarted = true;
                const response = yield this.beginAnalyzeHealthcare(this.documents, Object.assign(Object.assign({}, this.options.health), { abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal }));
                if (!response.operationLocation) {
                    throw new Error("Expects a valid 'operationLocation' to retrieve health results but did not find any");
                }
                state.jobId = getJobID(response.operationLocation);
            }
            const status = yield this.getHealthStatus(state.jobId, Object.assign(Object.assign({}, this.statusOptions), { abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal }));
            if (!state.isCompleted && status.done) {
                if (typeof options.fireProgress === "function") {
                    options.fireProgress(state);
                }
                const pagedIterator = this.listHealthcareEntitiesByPage(state.jobId, this.options.health || {});
                state.result = Object.assign(pagedIterator, {
                    statistics: status.statistics,
                    modelVersion: status.modelVersion
                });
                state.isCompleted = true;
            }
            return this;
        });
    }
    cancel() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            if (state.jobId) {
                yield this.client.cancelHealthJob(state.jobId, this.options.health);
            }
            state.isCancelled = true;
            return this;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits for the healthcare results.
 */
class BeginAnalyzeHealthcarePoller extends AnalysisPoller {
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    constructor(pollerOptions) {
        const { client, documents, analysisOptions, updateIntervalInMs = 5000, resumeFrom } = pollerOptions;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const { includeStatistics, requestOptions, tracingOptions } = analysisOptions || {};
        const operation = new BeginAnalyzeHealthcarePollerOperation(state || {}, client, documents, {
            health: analysisOptions,
            polling: {
                updateIntervalInMs,
                resumeFrom
            }
        }, 
        // take out modelVersion from the options that will be sent to the status
        // API because it is not applicable.
        { includeStatistics, requestOptions, tracingOptions });
        super(operation);
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return coreHttp.delay(this.updateIntervalInMs);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits for results of the analyze
 * operation.
 */
class BeginAnalyzePollerOperation extends AnalysisPollOperation {
    constructor(state, 
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, documents, tasks, options = {}, statusOptions = {}) {
        super(state);
        this.state = state;
        this.client = client;
        this.documents = documents;
        this.tasks = tasks;
        this.options = options;
        this.statusOptions = statusOptions;
    }
    /**
     * should be called only after all the status of the analyze jobs became
     * "succeeded" and it returns an iterator for the results and provides a
     * byPage method to return the results paginated.
     */
    listAnalyzeResults(jobId, options = {}) {
        const iter = this._listAnalyzeResultsPaginated(jobId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
                return this._listAnalyzeResultsPaginated(jobId, pageOptions);
            }
        };
    }
    /**
     * returns an iterator to arrays of the results of an analyze job.
     */
    _listAnalyzeResultsPaginated(jobId, options) {
        return tslib.__asyncGenerator(this, arguments, function* _listAnalyzeResultsPaginated_1() {
            let response = yield tslib.__await(this._listAnalyzeResultsSinglePage(jobId, options));
            yield yield tslib.__await(response.result);
            while (response.skip) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
                response = yield tslib.__await(this._listAnalyzeResultsSinglePage(jobId, optionsWithContinuation));
                yield yield tslib.__await(response.result);
            }
        });
    }
    /**
     * returns an iterator to arrays of the sorted results of an analyze job.
     */
    _listAnalyzeResultsSinglePage(jobId, options) {
        var _a, _b, _c;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listAnalyzeResultsSinglePage", options || {});
            try {
                const response = yield this.client.analyzeStatus(jobId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                const result = {
                    entitiesRecognitionResults: (_a = response.tasks.entityRecognitionTasks) === null || _a === void 0 ? void 0 : _a.map(({ results }) => makeRecognizeCategorizedEntitiesResultArray(this.documents, results === null || results === void 0 ? void 0 : results.documents, results === null || results === void 0 ? void 0 : results.errors, results === null || results === void 0 ? void 0 : results.modelVersion, results === null || results === void 0 ? void 0 : results.statistics)),
                    piiEntitiesRecognitionResults: (_b = response.tasks.entityRecognitionPiiTasks) === null || _b === void 0 ? void 0 : _b.map(({ results }) => makeRecognizePiiEntitiesResultArray(this.documents, results)),
                    keyPhrasesExtractionResults: (_c = response.tasks.keyPhraseExtractionTasks) === null || _c === void 0 ? void 0 : _c.map(({ results }) => makeExtractKeyPhrasesResultArray(this.documents, results === null || results === void 0 ? void 0 : results.documents, results === null || results === void 0 ? void 0 : results.errors, results === null || results === void 0 ? void 0 : results.modelVersion, results === null || results === void 0 ? void 0 : results.statistics))
                };
                return response.nextLink
                    ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * returns whether the analyze job is done and if so returns also
     * statistics.
     */
    getAnalyzeStatus(jobId, options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getAnalyzeStatus", options || {});
            try {
                const response = yield this.client.analyzeStatus(jobId, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                switch (response.status) {
                    case "partiallySucceeded":
                    case "succeeded": {
                        return {
                            done: true,
                            statistics: response.statistics
                        };
                    }
                    case "failed": {
                        const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const message = `Analysis failed. Error(s): ${errors || ""}`;
                        throw new Error(message);
                    }
                    case "notStarted":
                    case "running":
                        break;
                    default: {
                        throw new Error(`Unrecognized state of the analyze job!: ${response.status}`);
                    }
                }
                return { done: false };
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    beginAnalyze(documents, tasks, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyze", addStrEncodingParam(options));
            try {
                return yield this.client.analyze(Object.assign({ body: { analysisInput: { documents: documents }, tasks: tasks } }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions)));
            }
            catch (e) {
                const exception = handleInvalidDocumentBatch(e);
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: exception.message
                });
                throw exception;
            }
            finally {
                span.end();
            }
        });
    }
    update(options = {}) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            const updatedAbortSignal = options.abortSignal;
            if (!state.isStarted) {
                state.isStarted = true;
                const response = yield this.beginAnalyze(this.documents, this.tasks, Object.assign(Object.assign({}, this.options.analyze), { abortSignal: updatedAbortSignal ? updatedAbortSignal : (_a = this.options.analyze) === null || _a === void 0 ? void 0 : _a.abortSignal }));
                if (!response.operationLocation) {
                    throw new Error("Expects a valid 'operationLocation' to retrieve analyze results but did not find any");
                }
                state.jobId = getJobID(response.operationLocation);
            }
            const status = yield this.getAnalyzeStatus(state.jobId, Object.assign(Object.assign({}, this.statusOptions), { abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal }));
            if (!state.isCompleted && status.done) {
                if (typeof options.fireProgress === "function") {
                    options.fireProgress(state);
                }
                const pagedIterator = this.listAnalyzeResults(state.jobId, this.options.analyze || {});
                state.result = Object.assign(pagedIterator, {
                    statistics: status.statistics
                });
                state.isCompleted = true;
            }
            return this;
        });
    }
    cancel() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            logger.warning(`The service does not yet support cancellation for beginAnalyze.`);
            state.isCancelled = true;
            return this;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits for the analyze results.
 */
class BeginAnalyzePoller extends AnalysisPoller {
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    constructor(pollerOptions) {
        const { client, documents, analysisOptions, tasks, updateIntervalInMs = 5000, resumeFrom } = pollerOptions;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const { requestOptions, tracingOptions } = analysisOptions || {};
        const operation = new BeginAnalyzePollerOperation(state || {}, client, documents, tasks, {
            analyze: { requestOptions, tracingOptions },
            polling: {
                updateIntervalInMs,
                resumeFrom
            }
        }, analysisOptions);
        super(operation);
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return coreHttp.delay(this.updateIntervalInMs);
    }
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
(function (PiiEntityDomainType) {
    /**
     * See https://aka.ms/tanerpii for more information.
     */
    PiiEntityDomainType["PROTECTED_HEALTH_INFORMATION"] = "PHI";
})(exports.PiiEntityDomainType || (exports.PiiEntityDomainType = {}));
/**
 * Client class for interacting with Azure Text Analytics.
 */
class TextAnalyticsClient {
    /**
     * Creates an instance of TextAnalyticsClient.
     *
     * Example usage:
     * ```ts
     * import { TextAnalyticsClient, AzureKeyCredential } from "@azure/ai-text-analytics";
     *
     * const client = new TextAnalyticsClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param {string} endpointUrl The URL to the TextAnalytics endpoint
     * @param {TokenCredential | KeyCredential} credential Used to authenticate requests to the service.
     * @param {TextAnalyticsClientOptions} [options] Used to configure the TextAnalytics client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = tslib.__rest(options, ["defaultCountryHint", "defaultLanguage"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createTextAnalyticsAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(this.endpointUrl, pipeline);
    }
    detectLanguage(documents, countryHintOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const countryHint = countryHintOrOptions || this.defaultCountryHint;
                realInputs = convertToDetectLanguageInput(documents, countryHint);
                realOptions = options || {};
            }
            else {
                // Replace "none" hints with ""
                realInputs = documents.map((input) => (Object.assign(Object.assign({}, input), { countryHint: input.countryHint === "none" ? "" : input.countryHint })));
                realOptions = countryHintOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", realOptions);
            try {
                const result = yield this.client.languages({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeDetectLanguageResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeEntities(documents, languageOrOptions, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionGeneral({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeRecognizeCategorizedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                /**
                 * This special logic handles REST exception with code
                 * InvalidDocumentBatch and is needed to maintain backward compatability
                 * with sdk v5.0.0 and earlier. In general, REST exceptions are thrown as
                 * is and include both outer and inner exception codes. However, the
                 * earlier versions were throwing an exception that included the inner
                 * code only.
                 */
                const backwardCompatibleException = handleInvalidDocumentBatch(e);
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: backwardCompatibleException.message
                });
                throw backwardCompatibleException;
            }
            finally {
                span.end();
            }
        });
    }
    analyzeSentiment(documents, languageOrOptions, options) {
        var _a, _b, _c;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = {
                    includeStatistics: options === null || options === void 0 ? void 0 : options.includeStatistics,
                    modelVersion: options === null || options === void 0 ? void 0 : options.modelVersion,
                    opinionMining: options === null || options === void 0 ? void 0 : options.includeOpinionMining
                };
            }
            else {
                realInputs = documents;
                realOptions = {
                    includeStatistics: (_a = languageOrOptions) === null || _a === void 0 ? void 0 : _a.includeStatistics,
                    modelVersion: (_b = languageOrOptions) === null || _b === void 0 ? void 0 : _b.modelVersion,
                    opinionMining: (_c = languageOrOptions) === null || _c === void 0 ? void 0 : _c.includeOpinionMining
                };
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", realOptions);
            try {
                const result = yield this.client.sentiment({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeAnalyzeSentimentResultArray(realInputs, result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    extractKeyPhrases(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", realOptions);
            try {
                const result = yield this.client.keyPhrases({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeExtractKeyPhrasesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizePiiEntities(inputs, languageOrOptions, options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(inputs, language);
                realOptions = options || {};
                realOptions.domain = options === null || options === void 0 ? void 0 : options.domainFilter;
            }
            else {
                realInputs = inputs;
                realOptions = languageOrOptions || {};
                realOptions.domain = (_a = languageOrOptions) === null || _a === void 0 ? void 0 : _a.domainFilter;
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizePiiEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionPii({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeRecognizePiiEntitiesResultArray(realInputs, result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeLinkedEntities(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", realOptions);
            try {
                const result = yield this.client.entitiesLinking({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeRecognizeLinkedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    beginAnalyzeHealthcare(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const poller = new BeginAnalyzeHealthcarePoller(Object.assign({ client: this.client, documents: realInputs, analysisOptions: realOptions.health }, realOptions.polling));
            yield poller.poll();
            return poller;
        });
    }
    beginAnalyze(documents, tasks, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const compiledTasks = addEncodingParamToAnalyzeInput(tasks);
            const poller = new BeginAnalyzePoller(Object.assign({ client: this.client, documents: realInputs, tasks: compiledTasks, analysisOptions: realOptions.analyze }, realOptions.polling));
            yield poller.poll();
            return poller;
        });
    }
}
function addEncodingParamToAnalyzeInput(tasks) {
    var _a, _b, _c;
    return {
        entityRecognitionPiiTasks: (_a = tasks.entityRecognitionPiiTasks) === null || _a === void 0 ? void 0 : _a.map(addEncodingParamToTask).map(AddParamsToTask),
        entityRecognitionTasks: (_b = tasks.entityRecognitionTasks) === null || _b === void 0 ? void 0 : _b.map(addEncodingParamToTask).map(AddParamsToTask),
        keyPhraseExtractionTasks: (_c = tasks.keyPhraseExtractionTasks) === null || _c === void 0 ? void 0 : _c.map(AddParamsToTask)
    };
}
function isStringArray(documents) {
    return typeof documents[0] === "string";
}
function convertToDetectLanguageInput(inputs, countryHint) {
    if (countryHint === "none") {
        countryHint = "";
    }
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text
        };
    });
}
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text
        };
    });
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.TextAnalyticsClient = TextAnalyticsClient;
//# sourceMappingURL=index.js.map
