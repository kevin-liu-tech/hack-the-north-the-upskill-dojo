// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { RestError } from "@azure/core-http";
import { URL, URLSearchParams } from "./utils/url";
import { logger } from "./logger";
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * @ignore
 * @param sortedArray An array of entries sorted by `id`
 * @param unsortedArray An array of entries that contain `id` but are not sorted
 */
export function sortResponseIdObjects(sortedArray, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedArray.length) {
        const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    const result = [];
    for (const sortedItem of sortedArray) {
        const item = unsortedMap.get(sortedItem.id);
        if (item) {
            result.push(item);
        }
    }
    return result;
}
export function findOpinionIndex(pointer) {
    const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/opinions\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        const opinionIndex = {
            document: parseInt(res[1]),
            sentence: parseInt(res[2]),
            opinion: parseInt(res[3])
        };
        return opinionIndex;
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid opinion pointer`);
    }
}
const jsEncodingUnit = "Utf16CodeUnit";
export function addStrEncodingParam(options) {
    return Object.assign(Object.assign({}, options), { stringIndexType: jsEncodingUnit });
}
export function addEncodingParamToTask(task) {
    task.stringIndexType = jsEncodingUnit;
    return task;
}
export function AddParamsToTask(task) {
    return { parameters: task };
}
export function nextLinkToTopAndSkip(nextLink) {
    const url = new URL(nextLink);
    const searchParams = new URLSearchParams(url.searchParams);
    let top;
    if (searchParams.has("$top")) {
        top = parseInt(searchParams.get("$top"));
    }
    else {
        throw new Error(`nextLink URL does not have the $top param: ${nextLink}`);
    }
    let skip;
    if (searchParams.has("$skip")) {
        skip = parseInt(searchParams.get("$skip"));
    }
    else {
        throw new Error(`nextLink URL does not have the $skip param: ${nextLink}`);
    }
    return {
        skip: skip,
        top: top
    };
}
export function getJobID(operationLocation) {
    const lastSlashIndex = operationLocation.lastIndexOf("/");
    return operationLocation.substring(lastSlashIndex + 1);
}
/**
 * parses incoming errors from the service and if the inner error code is
 * InvalidDocumentBatch, it exposes that as the statusCode instead.
 * @param error the incoming error
 */
export function handleInvalidDocumentBatch(error) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const innerCode = (_d = (_c = (_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.innererror) === null || _d === void 0 ? void 0 : _d.code;
    const innerMessage = (_h = (_g = (_f = (_e = error.response) === null || _e === void 0 ? void 0 : _e.parsedBody) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.innererror) === null || _h === void 0 ? void 0 : _h.message;
    return innerCode === "InvalidDocumentBatch"
        ? new RestError(innerMessage, innerCode, error.statusCode)
        : error;
}
//# sourceMappingURL=util.js.map