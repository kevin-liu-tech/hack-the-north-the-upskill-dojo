// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncGenerator, __await, __awaiter } from "tslib";
import { operationOptionsToRequestOptionsBase } from "@azure/core-http";
import { addStrEncodingParam, getJobID, handleInvalidDocumentBatch, nextLinkToTopAndSkip } from "../../util";
import { AnalysisPollOperation } from "../poller";
import { CanonicalCode } from "@opentelemetry/api";
import { createSpan } from "../../tracing";
import { makeRecognizeCategorizedEntitiesResultArray } from "../../recognizeCategorizedEntitiesResultArray";
import { makeRecognizePiiEntitiesResultArray } from "../../recognizePiiEntitiesResultArray";
import { makeExtractKeyPhrasesResultArray } from "../../extractKeyPhrasesResultArray";
import { logger } from "../../logger";
/**
 * Class that represents a poller that waits for results of the analyze
 * operation.
 */
export class BeginAnalyzePollerOperation extends AnalysisPollOperation {
    constructor(state, 
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, documents, tasks, options = {}, statusOptions = {}) {
        super(state);
        this.state = state;
        this.client = client;
        this.documents = documents;
        this.tasks = tasks;
        this.options = options;
        this.statusOptions = statusOptions;
    }
    /**
     * should be called only after all the status of the analyze jobs became
     * "succeeded" and it returns an iterator for the results and provides a
     * byPage method to return the results paginated.
     */
    listAnalyzeResults(jobId, options = {}) {
        const iter = this._listAnalyzeResultsPaginated(jobId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
                return this._listAnalyzeResultsPaginated(jobId, pageOptions);
            }
        };
    }
    /**
     * returns an iterator to arrays of the results of an analyze job.
     */
    _listAnalyzeResultsPaginated(jobId, options) {
        return __asyncGenerator(this, arguments, function* _listAnalyzeResultsPaginated_1() {
            let response = yield __await(this._listAnalyzeResultsSinglePage(jobId, options));
            yield yield __await(response.result);
            while (response.skip) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
                response = yield __await(this._listAnalyzeResultsSinglePage(jobId, optionsWithContinuation));
                yield yield __await(response.result);
            }
        });
    }
    /**
     * returns an iterator to arrays of the sorted results of an analyze job.
     */
    _listAnalyzeResultsSinglePage(jobId, options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listAnalyzeResultsSinglePage", options || {});
            try {
                const response = yield this.client.analyzeStatus(jobId, operationOptionsToRequestOptionsBase(finalOptions));
                const result = {
                    entitiesRecognitionResults: (_a = response.tasks.entityRecognitionTasks) === null || _a === void 0 ? void 0 : _a.map(({ results }) => makeRecognizeCategorizedEntitiesResultArray(this.documents, results === null || results === void 0 ? void 0 : results.documents, results === null || results === void 0 ? void 0 : results.errors, results === null || results === void 0 ? void 0 : results.modelVersion, results === null || results === void 0 ? void 0 : results.statistics)),
                    piiEntitiesRecognitionResults: (_b = response.tasks.entityRecognitionPiiTasks) === null || _b === void 0 ? void 0 : _b.map(({ results }) => makeRecognizePiiEntitiesResultArray(this.documents, results)),
                    keyPhrasesExtractionResults: (_c = response.tasks.keyPhraseExtractionTasks) === null || _c === void 0 ? void 0 : _c.map(({ results }) => makeExtractKeyPhrasesResultArray(this.documents, results === null || results === void 0 ? void 0 : results.documents, results === null || results === void 0 ? void 0 : results.errors, results === null || results === void 0 ? void 0 : results.modelVersion, results === null || results === void 0 ? void 0 : results.statistics))
                };
                return response.nextLink
                    ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * returns whether the analyze job is done and if so returns also
     * statistics.
     */
    getAnalyzeStatus(jobId, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getAnalyzeStatus", options || {});
            try {
                const response = yield this.client.analyzeStatus(jobId, operationOptionsToRequestOptionsBase(finalOptions));
                switch (response.status) {
                    case "partiallySucceeded":
                    case "succeeded": {
                        return {
                            done: true,
                            statistics: response.statistics
                        };
                    }
                    case "failed": {
                        const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const message = `Analysis failed. Error(s): ${errors || ""}`;
                        throw new Error(message);
                    }
                    case "notStarted":
                    case "running":
                        break;
                    default: {
                        throw new Error(`Unrecognized state of the analyze job!: ${response.status}`);
                    }
                }
                return { done: false };
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    beginAnalyze(documents, tasks, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyze", addStrEncodingParam(options));
            try {
                return yield this.client.analyze(Object.assign({ body: { analysisInput: { documents: documents }, tasks: tasks } }, operationOptionsToRequestOptionsBase(finalOptions)));
            }
            catch (e) {
                const exception = handleInvalidDocumentBatch(e);
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: exception.message
                });
                throw exception;
            }
            finally {
                span.end();
            }
        });
    }
    update(options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            const updatedAbortSignal = options.abortSignal;
            if (!state.isStarted) {
                state.isStarted = true;
                const response = yield this.beginAnalyze(this.documents, this.tasks, Object.assign(Object.assign({}, this.options.analyze), { abortSignal: updatedAbortSignal ? updatedAbortSignal : (_a = this.options.analyze) === null || _a === void 0 ? void 0 : _a.abortSignal }));
                if (!response.operationLocation) {
                    throw new Error("Expects a valid 'operationLocation' to retrieve analyze results but did not find any");
                }
                state.jobId = getJobID(response.operationLocation);
            }
            const status = yield this.getAnalyzeStatus(state.jobId, Object.assign(Object.assign({}, this.statusOptions), { abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal }));
            if (!state.isCompleted && status.done) {
                if (typeof options.fireProgress === "function") {
                    options.fireProgress(state);
                }
                const pagedIterator = this.listAnalyzeResults(state.jobId, this.options.analyze || {});
                state.result = Object.assign(pagedIterator, {
                    statistics: status.statistics
                });
                state.isCompleted = true;
            }
            return this;
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            logger.warning(`The service does not yet support cancellation for beginAnalyze.`);
            state.isCancelled = true;
            return this;
        });
    }
}
//# sourceMappingURL=operation.js.map