// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
import { operationOptionsToRequestOptionsBase } from "@azure/core-http";
import { addStrEncodingParam, getJobID, handleInvalidDocumentBatch, nextLinkToTopAndSkip } from "../../util";
import { AnalysisPollOperation } from "../poller";
import { combineSuccessfulAndErroneousDocuments } from "../../textAnalyticsResult";
import { CanonicalCode } from "@opentelemetry/api";
import { createSpan } from "../../tracing";
/**
 * Class that represents a poller that waits for the healthcare results.
 */
export class BeginAnalyzeHealthcarePollerOperation extends AnalysisPollOperation {
    constructor(state, 
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, documents, options = {}, statusOptions) {
        super(state);
        this.state = state;
        this.client = client;
        this.documents = documents;
        this.options = options;
        this.statusOptions = statusOptions;
    }
    /**
     * should be called only after all the status of the healthcare jobs became
     * "succeeded" and it returns an iterator for the results and provides a
     * byPage method to return the results paginated.
     */
    listHealthcareEntitiesByPage(jobId, options = {}) {
        const iter = this._listHealthcareEntities(jobId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
                return this._listHealthcareEntitiesPaginated(jobId, pageOptions);
            }
        };
    }
    /**
     * returns an iterator to the results of a healthcare job.
     */
    _listHealthcareEntities(jobId, options) {
        return __asyncGenerator(this, arguments, function* _listHealthcareEntities_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this._listHealthcareEntitiesPaginated(jobId, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * returns an iterator to arrays of the results of a healthcare job.
     */
    _listHealthcareEntitiesPaginated(jobId, options) {
        return __asyncGenerator(this, arguments, function* _listHealthcareEntitiesPaginated_1() {
            let response = yield __await(this._listHealthcareEntitiesSinglePage(jobId, options));
            yield yield __await(response.result);
            while (response.skip) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
                response = yield __await(this._listHealthcareEntitiesSinglePage(jobId, optionsWithContinuation));
                yield yield __await(response.result);
            }
        });
    }
    /**
     * returns an iterator to arrays of the sorted results of a healthcare job.
     */
    _listHealthcareEntitiesSinglePage(jobId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listHealthcareEntitiesSinglePage", options || {});
            try {
                const response = yield this.client.healthStatus(jobId, operationOptionsToRequestOptionsBase(finalOptions));
                if (response.results) {
                    const result = combineSuccessfulAndErroneousDocuments(this.documents, response.results);
                    return response.nextLink
                        ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
                }
                else {
                    throw new Error("Healthcare task has succeeded but the there are no results!");
                }
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * returns whether the healthcare job is done and if so returns also
     * statistics and the model version used.
     */
    getHealthStatus(jobId, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getHealthStatus", options || {});
            try {
                const response = yield this.client.healthStatus(jobId, operationOptionsToRequestOptionsBase(finalOptions));
                switch (response.status) {
                    case "succeeded": {
                        if (response.results) {
                            return {
                                done: true,
                                statistics: response.results.statistics,
                                modelVersion: response.results.modelVersion
                            };
                        }
                        else {
                            throw new Error("Healthcare task has succeeded but the there are no results!");
                        }
                    }
                    case "failed": {
                        const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const message = `Healthcare analysis failed. Error(s): ${errors || ""}`;
                        throw new Error(message);
                    }
                    case "notStarted":
                    case "running":
                        break;
                    default: {
                        throw new Error("Unrecognized state of healthcare job!");
                    }
                }
                return { done: false };
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    beginAnalyzeHealthcare(documents, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyzeHealthcare", addStrEncodingParam(options));
            try {
                return yield this.client.health({ documents: documents }, operationOptionsToRequestOptionsBase(finalOptions));
            }
            catch (e) {
                const exception = handleInvalidDocumentBatch(e);
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: exception.message
                });
                throw exception;
            }
            finally {
                span.end();
            }
        });
    }
    update(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            const updatedAbortSignal = options.abortSignal;
            if (!state.isStarted) {
                state.isStarted = true;
                const response = yield this.beginAnalyzeHealthcare(this.documents, Object.assign(Object.assign({}, this.options.health), { abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal }));
                if (!response.operationLocation) {
                    throw new Error("Expects a valid 'operationLocation' to retrieve health results but did not find any");
                }
                state.jobId = getJobID(response.operationLocation);
            }
            const status = yield this.getHealthStatus(state.jobId, Object.assign(Object.assign({}, this.statusOptions), { abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal }));
            if (!state.isCompleted && status.done) {
                if (typeof options.fireProgress === "function") {
                    options.fireProgress(state);
                }
                const pagedIterator = this.listHealthcareEntitiesByPage(state.jobId, this.options.health || {});
                state.result = Object.assign(pagedIterator, {
                    statistics: status.statistics,
                    modelVersion: status.modelVersion
                });
                state.isCompleted = true;
            }
            return this;
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            if (state.jobId) {
                yield this.client.cancelHealthJob(state.jobId, this.options.health);
            }
            state.isCancelled = true;
            return this;
        });
    }
}
//# sourceMappingURL=operation.js.map