{"version":3,"file":"analyzeSentimentResult.js","sourceRoot":"","sources":["../../src/analyzeSentimentResult.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EACL,8BAA8B,EAG9B,4BAA4B,EAC7B,MAAM,uBAAuB,CAAC;AAc/B,OAAO,EAAE,gBAAgB,EAAgB,MAAM,QAAQ,CAAC;AAgHxD,MAAM,UAAU,0BAA0B,CACxC,QAA2B;IAE3B,MAAM,EACJ,EAAE,EACF,SAAS,EACT,gBAAgB,EAChB,kBAAkB,EAAE,SAAS,EAC7B,QAAQ,EACR,UAAU,EACX,GAAG,QAAQ,CAAC;IACb,uCACK,8BAA8B,CAAC,EAAE,EAAE,QAAQ,EAAE,UAAU,CAAC,KAC3D,SAAS;QACT,gBAAgB,EAChB,SAAS,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,iCAAiC,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,IAC7F;AACJ,CAAC;AAED,MAAM,UAAU,+BAA+B,CAC7C,EAAU,EACV,KAAyB;IAEzB,OAAO,4BAA4B,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AACjD,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,iCAAiC,CACxC,QAAoC,EACpC,QAA2B;IAE3B,OAAO;QACL,gBAAgB,EAAE,QAAQ,CAAC,gBAAgB;QAC3C,SAAS,EAAE,QAAQ,CAAC,SAAS;QAC7B,IAAI,EAAE,QAAQ,CAAC,IAAI;QACnB,MAAM,EAAE,QAAQ,CAAC,MAAM;QACvB,aAAa,EAAE,QAAQ,CAAC,OAAO;YAC7B,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAClB,CAAC,MAAsB,EAAgB,EAAE,CAAC,CAAC;gBACzC,MAAM,EAAE;oBACN,gBAAgB,EAAE,MAAM,CAAC,gBAAgB;oBACzC,SAAS,EAAE,MAAM,CAAC,SAAS;oBAC3B,IAAI,EAAE,MAAM,CAAC,IAAI;oBACjB,MAAM,EAAE,MAAM,CAAC,MAAM;iBACtB;gBACD,QAAQ,EAAE,MAAM,CAAC,SAAS;qBACvB,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,YAAY,KAAK,SAAS,CAAC;qBACzD,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,uCAAuC,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;aAClF,CAAC,CACH;YACH,CAAC,CAAC,EAAE;KACP,CAAC;AACJ,CAAC;AAED;;;;;;;;GAQG;AACH,SAAS,uCAAuC,CAC9C,cAA8B,EAC9B,QAA2B;;IAE3B,MAAM,UAAU,GAAG,cAAc,CAAC,GAAG,CAAC;IACtC,MAAM,YAAY,GAAiB,gBAAgB,CAAC,UAAU,CAAC,CAAC;IAChE,MAAM,OAAO,eACX,QAAQ,CAAC,kBAAkB,0CAAG,YAAY,CAAC,QAAQ,EAAE,QAAQ,0CAAG,YAAY,CAAC,OAAO,CAAC,CAAC;IACxF,IAAI,OAAO,KAAK,SAAS,EAAE;QACzB,OAAO,OAAO,CAAC;KAChB;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,YAAY,UAAU,kCAAkC,CAAC,CAAC;KAC3E;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  makeTextAnalyticsErrorResult\n} from \"./textAnalyticsResult\";\nimport {\n  TextAnalyticsError,\n  DocumentSentimentLabel,\n  SentimentConfidenceScores,\n  SentenceSentiment as GeneratedSentenceSentiment,\n  SentenceSentimentLabel,\n  DocumentSentiment,\n  SentenceAspect,\n  AspectRelation,\n  SentenceOpinion,\n  TokenSentimentValue as SentenceAspectSentiment,\n  AspectConfidenceScoreLabel\n} from \"./generated/models\";\nimport { findOpinionIndex, OpinionIndex } from \"./util\";\n\n/**\n * The result of the analyze sentiment operation on a single document.\n */\nexport type AnalyzeSentimentResult = AnalyzeSentimentSuccessResult | AnalyzeSentimentErrorResult;\n\n/**\n *  The result of the analyze sentiment operation on a single document,\n *  containing the predicted sentiment for each sentence as well as for the full document.\n */\nexport interface AnalyzeSentimentSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * Predicted sentiment for document. Possible values\n   * include: 'positive', 'neutral', 'negative', 'mixed'\n   */\n  sentiment: DocumentSentimentLabel;\n  /**\n   * Document level sentiment confidence scores between 0 and 1 for each sentiment class.\n   */\n  confidenceScores: SentimentConfidenceScores;\n  /**\n   * The predicted sentiment for each sentence in the corresponding document.\n   */\n  sentences: SentenceSentiment[];\n}\n\n/**\n * The predicted sentiment for a given span of text. For more information regarding text sentiment, see https://docs.microsoft.com/azure/cognitive-services/Text-Analytics/how-tos/text-analytics-how-to-sentiment-analysis.\n */\nexport interface SentenceSentiment {\n  /**\n   * The sentence text.\n   */\n  text: string;\n  /**\n   * The predicted Sentiment for the sentence.\n   */\n  sentiment: SentenceSentimentLabel;\n  /**\n   * The sentiment confidence score between 0 and 1 for the sentence for all classes.\n   */\n  confidenceScores: SentimentConfidenceScores;\n  /**\n   * The sentence text offset from the start of the document.\n   */\n  offset: number;\n  /**\n   * The list of opinions mined from this sentence. For example in \"The food is\n   * good, but the service is bad\", we would mind these two opinions \"food is\n   * good\", \"service is bad\". Only returned if `show_opinion_mining` is set to\n   * True in the call to `analyze_sentiment`.\n   */\n  minedOpinions: MinedOpinion[];\n}\n\n/**\n * AspectSentiment contains the related opinions, predicted sentiment,\n * confidence scores and other information about an aspect of a product.\n * An aspect of a product/service is a key component of that product/service.\n * For example in \"The food at Hotel Foo is good\", \"food\" is an aspect of\n * \"Hotel Foo\".\n */\nexport interface AspectSentiment {\n  /**\n   * The sentiment confidence score between 0 and 1 for the aspect for\n   * 'positive' and 'negative' labels.\n   */\n  confidenceScores: AspectConfidenceScoreLabel;\n  /**\n   * The predicted Sentiment for the aspect. Possible values include 'positive',\n   * 'mixed', and 'negative'.\n   */\n  sentiment: SentenceAspectSentiment;\n  /**\n   * The aspect text.\n   */\n  text: string;\n  /**\n   * The aspect text offset from the start of the sentence.\n   */\n  offset: number;\n}\n\n/**\n * OpinionSentiment contains the predicted sentiment, confidence scores and\n * other information about an opinion of an aspect. For example, in the sentence\n * \"The food is good\", the opinion of the aspect 'food' is 'good'.\n */\nexport interface OpinionSentiment extends SentenceOpinion {}\n\n/**\n * A mined opinion object represents an opinion we've extracted from a sentence.\n * It consists of both an aspect that these opinions are about, and the actual\n * opinions themselves.\n */\nexport interface MinedOpinion {\n  /**\n   * The aspect of a product/service that this opinion is about.\n   */\n  aspect: AspectSentiment;\n  /**\n   * The actual opinions of the aspect.\n   */\n  opinions: OpinionSentiment[];\n}\n\n/**\n * An error result from the analyze sentiment operation on a single document.\n */\nexport type AnalyzeSentimentErrorResult = TextAnalyticsErrorResult;\n\nexport function makeAnalyzeSentimentResult(\n  document: DocumentSentiment\n): AnalyzeSentimentSuccessResult {\n  const {\n    id,\n    sentiment,\n    confidenceScores,\n    sentenceSentiments: sentences,\n    warnings,\n    statistics\n  } = document;\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    sentiment,\n    confidenceScores,\n    sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, document))\n  };\n}\n\nexport function makeAnalyzeSentimentErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): AnalyzeSentimentErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n\n/**\n * Converts a sentence sentiment object returned by the service to another that\n * is user-friendly.\n *\n * @param sentence - The sentence sentiment object to be converted.\n * @param response - The entire response returned by the service.\n * @returns The user-friendly sentence sentiment object.\n */\nfunction convertGeneratedSentenceSentiment(\n  sentence: GeneratedSentenceSentiment,\n  document: DocumentSentiment\n): SentenceSentiment {\n  return {\n    confidenceScores: sentence.confidenceScores,\n    sentiment: sentence.sentiment,\n    text: sentence.text,\n    offset: sentence.offset,\n    minedOpinions: sentence.aspects\n      ? sentence.aspects.map(\n          (aspect: SentenceAspect): MinedOpinion => ({\n            aspect: {\n              confidenceScores: aspect.confidenceScores,\n              sentiment: aspect.sentiment,\n              text: aspect.text,\n              offset: aspect.offset\n            },\n            opinions: aspect.relations\n              .filter((relation) => relation.relationType === \"opinion\")\n              .map((relation) => convertAspectRelationToOpinionSentiment(relation, document))\n          })\n        )\n      : []\n  };\n}\n\n/**\n * Converts an aspect relation object returned by the service to an opinion\n * sentiment object where JSON pointers in the former are realized in the\n * latter.\n *\n * @param aspectRelation - The aspect relation object to be converted.\n * @param response - The entire response returned by the service.\n * @returns The user-friendly opinion sentiment object.\n */\nfunction convertAspectRelationToOpinionSentiment(\n  aspectRelation: AspectRelation,\n  document: DocumentSentiment\n): OpinionSentiment {\n  const opinionPtr = aspectRelation.ref;\n  const opinionIndex: OpinionIndex = findOpinionIndex(opinionPtr);\n  const opinion: SentenceOpinion | undefined =\n    document.sentenceSentiments?.[opinionIndex.sentence].opinions?.[opinionIndex.opinion];\n  if (opinion !== undefined) {\n    return opinion;\n  } else {\n    throw new Error(`Pointer \"${opinionPtr}\" is not a valid opinion pointer`);\n  }\n}\n"]}